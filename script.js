const words = [
  "abandon",
  "beacon",
  "candy",
  "dove",
  "eagle",
  "flame",
  "grape",
  "happy",
  "ice",
  "jungle",
  "kingdom",
  "lunar",
  "mango",
  "noble",
  "ocean",
  "petal",
  "quest",
  "river",
  "shadow",
  "train",
  "umbrella",
  "vivid",
  "whale",
  "basket",
  "yellow",
  "zebra",
  "angel",
  "brave",
  "crane",
  "dusk",
  "enigma",
  "frost",
  "glow",
  "honey",
  "index",
  "juice",
  "knight",
  "lunar",
  "magic",
  "night",
  "oasis",
  "pearl",
  "quill",
  "rose",
  "scent",
  "tiger",
  "unity",
  "vortex",
  "wind",
  "xray",
  "yogurt",
  "zoned",
  "atlas",
  "bliss",
  "cider",
  "dawn",
  "epoch",
  "flame",
  "gauge",
  "heaven",
  "irony",
  "jolly",
  "koala",
  "lamb",
  "mint",
  "neon",
  "opal",
  "plum",
  "quartz",
  "ruby",
  "sunset",
  "tango",
  "urban",
  "vogue",
  "wave",
  "xerox",
  "yearn",
  "zephyr",
  "aqua",
  "bold",
  "crisp",
  "dove",
  "edge",
  "forge",
  "grace",
  "hush",
  "ink",
  "jade",
  "kite",
  "leaf",
  "mist",
  "navy",
  "oak",
  "pale",
  "quilted",
  "rare",
  "stone",
  "tone",
  "urban",
  "vibes",
  "wisp",
  "yacht",
  "zeal",
  "arc",
  "blaze",
  "core",
  "dust",
  "echo",
  "flint",
  "gaze",
  "halo",
  "iron",
  "june",
  "kale",
  "lime",
  "moss",
  "nest",
  "ore",
  "peach",
  "quail",
  "ridge",
  "snow",
  "tide",
  "use",
  "vow",
  "window",
  "xmas",
  "yoga",
  "zoo",
  "amber",
  "breeze",
  "clover",
  "drift",
  "enjoy",
  "flame",
  "grin",
  "hatch",
  "icicle",
  "jazz",
  "knack",
  "latch",
  "mocha",
  "nail",
  "open",
  "pale",
  "quiz",
  "rust",
  "sail",
  "tide",
  "ugly",
  "vowed",
  "wool",
  "xenon",
  "yawned",
  "zone",
  "awe",
  "belt",
  "charm",
  "dome",
  "elixir",
  "fawn",
  "gala",
  "hop",
  "inc",
  "june",
  "knot",
  "lump",
  "moon",
  "noon",
  "opal",
  "pier",
  "quiver",
  "ride",
  "stare",
  "twin",
  "unit",
  "vase",
  "wax",
  "yolk",
  "zoom",
  "arrow",
  "brick",
  "cloud",
  "dune",
  "eagle",
  "frost",
  "grip",
  "haze",
  "ignite",
  "jacket",
  "lure",
  "mesh",
  "nest",
  "ogre",
  "puff",
  "quilt",
  "rave",
  "swoop",
  "track",
  "urge",
  "view",
  "windy",
  "yell",
  "zen",
  "bolt",
  "clip",
  "deep",
  "echo",
  "flare",
  "gaze",
  "heron",
  "iris",
  "jolt",
  "key",
  "lily",
  "mint",
  "nook",
  "olive",
  "plow",
  "quill",
  "rust",
  "sage",
  "tick",
  "uniform",
  "vibe",
  "whip",
  "yarn",
  "zoomed",
  "art",
  "blow",
  "core",
  "dove",
  "eagle",
  "foam",
  "gloom",
  "hand",
  "ice",
  "joke",
  "knee",
  "loaf",
  "melt",
  "note",
  "open",
  "pale",
  "quill",
  "roar",
  "slug",
  "tear",
  "urge",
  "blank",
  "wait",
  "yawn",
  "zinc",
];

const textContainer = document.getElementById("text-container");
const timerElement = document.getElementById("timer");
const restartButton = document.getElementById("restart-button");
const finalScoreElement = document.getElementById("final-score");

// Shuffle words array
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function getRandomText() {
  const shuffledWords = shuffleArray([...words]);
  return shuffledWords.join(" ");
}

let totalTyped = "";
let currentCharIndex = 0;
let errors = 0;
let longText = getRandomText();
let timeleft = 60;
let timeInterval = null;
let typingStarted = false;



//Tmer logic

function startTimer() {
  if (!typingStarted) {
    typingStarted = true;
    timeInterval = setInterval(() => {
      timeleft--;
      timerElement.textContent = `Time Left: ${timeleft}s`;
      if (timeleft <= 0) {
        clearInterval(timeInterval);
        endTest();
      }
    }, 1000);
  }
}

const endTest = () => {
  timerElement.textContent = `Time's up!`;
  finalScoreElement.textContent = `Final WPM: ${calculateWPM()}`;
  textContainer.style.display = "none";
  restartButton.style.display = "block";

  //  stop further input
  document.removeEventListener("keydown", keyboardInput);
};

// calculate wpm
const calculateWPM = () => {
  const wordsTyped = totalTyped.trim().split(/\s+/).length;
  const baseWPM = Math.round((wordsTyped)/60 *60);
  const adjustedWPM = Math.max(baseWPM - errors, 0);
  return adjustedWPM;
};

// Initialize the typing test
function initializeTest() {
  longText = getRandomText();
  textContainer.textContent = longText;
  console.log(longText);
}

// Initialize on page load
initializeTest();

// Keyboard Input
const keyboardInput = (e) => {
  startTimer();
  const key = e.key;
  if (key === "ArrowRight") {
    textContainer.scrollLeft += 20;
    return;
  }

  if (key === "ArrowLeft") {
    textContainer.scrollLeft -= 20;
    return;
  }
  if (key === "Backspace") {
    if (totalTyped.length > 0) {
      currentCharIndex = Math.max(0, currentCharIndex - 1);
      totalTyped = totalTyped.slice(0, -1);
    }
  } else if (key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
    totalTyped += key;
    currentCharIndex += 1;
  }
  
  const textArray = longText.split("");

  textContainer.innerText = "";
  errors = 0;

  //coloring logic
  for (let i = 0; i < textArray.length; i++) {
    const span = document.createElement("span");
    if (i < totalTyped.length) {
      if (totalTyped[i] === textArray[i]) {
        span.classList.add("correct");
      } else {
        span.classList.add("error");
        errors++;
      }
    }
    span.textContent = textArray[i];
    textContainer.appendChild(span);
  }
  if (totalTyped.length >= 20) {
    const scrolledAmount = (totalTyped.length - 20) * 14;
    textContainer.scrollLeft = scrolledAmount;
  }
};

// Reset the test
function resetTest() {
  clearInterval(timeInterval);

  timeleft = 60; // your timer
  timerElement.textContent = `Time Left: ${timeleft}s`;
  finalScoreElement.textContent = "";

  textContainer.style.display = "block";
  restartButton.style.display = "none"; 

  totalTyped = "";
  typingStarted = false;
  currentCharIndex = 0;
  errors = 0;

  textContainer.scrollLeft = 0;

  longText = getRandomText();
  textContainer.textContent = longText;  // rebuild original text

  // re-enable keyboard typing
  document.addEventListener("keydown", keyboardInput);
}


restartButton.addEventListener("click" , resetTest);

document.addEventListener("keydown", keyboardInput);
